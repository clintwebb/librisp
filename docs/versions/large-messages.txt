The existing library handles messages of all sizes exactly the same, by reading all the data into memory, and then process it.  The 
problem with that is that many implementations of software using the risp library may have very limited memory.

In that case, large messages need to be handled very carefully.

To account for this, we can instead have the data stored to a temporary file.  This makes it complicated, because then how do we 
process the file?  It makes little sence to bother putting the data in a file, if we then need to load the entire file into memory.  
Some systems might be able to assume that if you allocate more memory than you have, you could rely on SWAP to move things out to disk, 
but that might not work very well in some systems.  Indeed some systems will not have swap space at all.

When Initialising the RISP interface, will provide different callbacks for large messages.  These callbacks will be given a file handle 
instead of a block of memory, and then it can process it however it likes.

We will also need to be able to process a RISP stream from a file handle as well, because very likely the large amount of data could 
very well be wrapping more RISP commands.


-----------

Functional change. 

When specifying the callback routine for string commands, can indicate a limit.

Can also set a temporary file location.  This means that messages that are larger than the specified limit should be put in a temporary file.  

If no temporary location is set, then when the limit is reached, the message will be discarded.  This is to protect the system from receiving messages larger than it can handle.   

Therefore, all the callbacks for strings, should be changed to include a file handle.  If the file handle is -1, then the data should be in the buffer.  If the file handle is 0 or greater, then the callback should then be responsible for loading the data out of the file.   

If a message is being rejected, how should that be handled?  I guess, we can set a reject handler.

-------

I've hit a problem in my implementation.  risp_process is context unaware.  If it starts writing to a temporary file, how will it know which context belongs to which file?  Presuming that not all the data is available in the buffer, when it has more data, it will be run again.

I need to make some streaming changes to the code instead, so that we simply attach a socket, and all the socket handling is then done in the library itself.  Might be better to split that into a different library.  Maybe librispstream.


